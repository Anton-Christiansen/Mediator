using System.Collections.Generic;
using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Mediator.SourceGenerators;

[Generator]
public class RequestHandlerIncrementalSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.CreateSyntaxProvider(static (ctx, _) => ctx is ClassDeclarationSyntax,
                    static (ctx, _) => GetClassDeclarationForSourceGen(ctx))
                .Where(x => x.interfaceFound)
                .Select((x, _) => x.Item1);

        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
    }
    

    private static (ClassDeclarationSyntax, bool interfaceFound) GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        var declaration = (ClassDeclarationSyntax)context.Node;
        if (context.SemanticModel.GetDeclaredSymbol(declaration) is not ITypeSymbol typeSymbol)
            return (declaration, false);

        foreach (var @interface in typeSymbol.AllInterfaces)
        {
            if (@interface.Name.StartsWith("IRequestHandler") || (@interface.BaseType is not null && @interface.BaseType.Name.StartsWith("IRequestHandler")))
            {
                return (declaration, true);
            }
        }

        return (declaration, false);
    }

    private static void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations)
    {
        
        if (classDeclarations.IsEmpty)
        {
            return;
        }


        var extensionMethodBuilder = new StringBuilder();
        var extensionBodyBuilder = new StringBuilder();

        extensionMethodBuilder
            .AppendLine("""
                          // <auto-generated/>

                          using System;
                          using Mediator.Interfaces;
                          using Mediator.Helpers;
                          using Microsoft.Extensions.DependencyInjection;
                          using Microsoft.Extensions.DependencyInjection.Extensions;
                          """);
        
        HashSet<string> namespaces = [];
        
        foreach (var classDeclaration in classDeclarations)
        {
            var semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);

            if (semanticModel.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol classSymbol)
                continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
            if (namespaceName != "Mediator")
            {
                if (namespaces.Add(namespaceName)) extensionMethodBuilder.AppendLine($"using {namespaceName};");
            }


            // 'Identifier' means the token of the node. Get class name from the syntax node.
            var className = classSymbol.OriginalDefinition.ToString();

            foreach (var @interface in classSymbol.AllInterfaces)
            {
                if (@interface.Name.StartsWith("IRequestHandler")  || (@interface.BaseType is not null && @interface.BaseType.Name.StartsWith("IRequestHandler")))
                {
                    var interfaceName = @interface.ToString();

                    var start = interfaceName.IndexOf('<');
                    var end = interfaceName.LastIndexOf('>');


                    string genericType = interfaceName.Substring(start + 1, end - start - 1);

                    extensionBodyBuilder.AppendLine(
                        $"\t\tbuilder.Services.TryAddTransient<IRequestHandler<{genericType}>, {className}>();");
                    break;
                }
            }
        }
        

        extensionMethodBuilder
            .AppendLine($$"""
                          
                          namespace Mediator.DependencyInjection;
                          
                          public static class HandlerDependencyInjection{{compilation.AssemblyName}}RegistrationExtensions
                          {
                              public static MediatorBuilder WireHandlersFrom{{compilation.AssemblyName}}(this MediatorBuilder builder)
                              {
                          {{extensionBodyBuilder}}
                                    return builder;
                               }
                          }
                          """);

        var extensionSource = extensionMethodBuilder.ToString();

        context.AddSource($"MediatorHandlerDependencyInjection.g.cs", extensionSource);
        
    }

}