using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Mediator.SourceGenerators;

[Generator]
public class NotificationIncrementalSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.CreateSyntaxProvider(static (ctx, _) => ctx is ClassDeclarationSyntax,
                    static (ctx, _) => GetClassDeclarationForSourceGen(ctx))
                .Where(x => x.interfaceFound)
                .Select((x, _) => x.Item1);

        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
    }
    

    private static (ClassDeclarationSyntax, bool interfaceFound) GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        var declaration = (ClassDeclarationSyntax)context.Node;
        if (context.SemanticModel.GetDeclaredSymbol(declaration) is not ITypeSymbol typeSymbol)
            return (declaration, false);

        foreach (var @interface in typeSymbol.AllInterfaces)
        {
            if (@interface.Name.StartsWith("INotificationHandler"))
            {
                return (declaration, true);
            }
        }

        return (declaration, false);
    }

    private static void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations)
    {
        if (classDeclarations.IsDefaultOrEmpty) return;

        //var l = compilation.SourceModule.ReferencedAssemblySymbols.First(x => x.Identity.Name == "Mediator");
            
           // .First(x => x.ContainingAssembly?.Name == "Mediator"); 
        
        
        List<(string notification, List<(string fullName, string className)> handlers)> notifications = [];

        
        var dependencyInjectionBuilder = new StringBuilder();
        dependencyInjectionBuilder.AppendLine("""
                                              // <auto-generated/>

                                              using System;
                                              using Mediator.Interfaces;
                                              using Mediator.Helpers;
                                              using Microsoft.Extensions.DependencyInjection;
                                              using Microsoft.Extensions.DependencyInjection.Extensions;
                                              """);
        
        HashSet<string> namespaces = [];
        
        foreach (var classDeclaration in classDeclarations)
        {
            var semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);

            if (semanticModel.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol classSymbol)
                continue;
            
            
            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
            if (namespaceName != "Notifier")
            {
                if (namespaces.Add(namespaceName)) dependencyInjectionBuilder.AppendLine($"using {namespaceName};");
            }
            
            var className = classSymbol.OriginalDefinition.ToString();



            foreach (var @interface in classSymbol.AllInterfaces)
            {
                if (@interface.Name.StartsWith("INotificationHandler"))
                {
                    var interfaceName = @interface.ToString();

                    var start = interfaceName.IndexOf('<');
                    var end = interfaceName.LastIndexOf('>');

                    string genericType = interfaceName.Substring(start + 1, end - start - 1);
                    bool notfound = true;
                    for (var index = 0; index < notifications.Count; index++)
                    {
                        var notification = notifications[index];
                        if (notification.notification == genericType)
                        {
                            notfound = false;
                            notifications[index].handlers.Add((className, classSymbol.Name));
                            break;
                        }
                    }

                    if (notfound)
                    {
                        notifications.Add((genericType, [(className, classSymbol.Name)]));
                    }
                }

            }

        }


        
         
        
        
        
        dependencyInjectionBuilder
            .AppendLine($$"""

                        namespace Mediator.DependencyInjection;

                        public static class NotificationDependencyInjection{{compilation.AssemblyName}}RegistrationExtensions
                        {
                            public static NotificationBuilder WireNotificationsFrom{{compilation.AssemblyName}}(this NotificationBuilder builder)
                            {
                        """);
        
        
        
        
        
        foreach (var notification in notifications)
        {
            // resolve handlers and call
            foreach (var handler in notification.handlers)
            {
                // Add dependencies
                dependencyInjectionBuilder.AppendLine($"\t\tbuilder.Services.AddTransient<INotificationHandler<{notification.notification}>, {handler.fullName}>();");
            }
        }

        dependencyInjectionBuilder.AppendLine("""
                                                 return builder;
                                                 }
                                              }
                                              """);
        
        
        // generate 
        var dependencyInjectionSource = dependencyInjectionBuilder.ToString();

        ;
        context.AddSource($"MediatorNotificationDependencyInjection.g.cs", dependencyInjectionSource);
    }

}