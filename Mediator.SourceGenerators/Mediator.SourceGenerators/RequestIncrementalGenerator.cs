using System.Collections.Immutable;
using System.Linq;
using Mediator.SourceGenerators.Helpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Mediator.SourceGenerators;

[Generator]
public class RequestIncrementalGenerator : IIncrementalGenerator
{
    private record Handler(string Namespace, string GenericType, string FullyQualifiedClassName)
    {
        public string Namespace { get; } = Namespace;
        public string GenericType { get; } = GenericType;
        public string FullyQualifiedClassName { get; } = FullyQualifiedClassName;
    }
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.CreateSyntaxProvider(
                static (ctx, _) => ctx is ClassDeclarationSyntax,
                static (ctx, _) => Transform(ctx))
            .Where(x => x.Found)
            .Select((x, _) => x.Handler!);

        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
    }


    private static (Handler? Handler, bool Found) Transform(GeneratorSyntaxContext context)
    {
        var declaration = (ClassDeclarationSyntax)context.Node;
        if (context.SemanticModel.GetDeclaredSymbol(declaration) is not INamedTypeSymbol typeSymbol)
            return (null, false);
        
        var result = GetHandlerFromSymbol(typeSymbol, out var handler);
        return (handler, result);
    }
    
    private static bool GetHandlerFromSymbol(INamedTypeSymbol symbol, out Handler? handler)
    {
        handler = null;
        
        foreach (var @interface in symbol.AllInterfaces)
        {
            var fullyQualifiedInterfaceName = @interface.ToString();
            if (fullyQualifiedInterfaceName.StartsWith("Mediator.Interfaces.IRequestHandler") is false) continue;
          
            string interfaceName = fullyQualifiedInterfaceName;
            int start = interfaceName.IndexOf('<');
            int end = interfaceName.LastIndexOf('>');
            interfaceName = interfaceName.Substring(start + 1,  end - start - 1);
                        
            handler = new Handler(symbol.ContainingNamespace.ToString(), interfaceName, symbol.ToString());
            return true;
        }
        
        return false;
    }

    private static void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<Handler> handlers)
    {
        foreach (var assembly in compilation.SourceModule.ReferencedAssemblySymbols)
        {
            foreach (var type in TypeHelper.GetAllTypes(assembly.GlobalNamespace))
            {
                if (type.TypeKind != TypeKind.Class) continue;

                if (GetHandlerFromSymbol(type, out var handler) is false) continue;
                
                handlers = handlers.Add(handler!);
            }
        }
        
        handlers = handlers.Distinct().ToImmutableArray();
        var namespaces = handlers.Select(x => x.Namespace).Distinct().ToArray();
        
        context.AddSource("MediatorHandlersDependencyInjection.g.cs",
            $$"""
              // <auto-generated/>
              
              using System;
              using Mediator.Interfaces;
              using Mediator.Helpers;
              using Microsoft.Extensions.DependencyInjection;
              using Microsoft.Extensions.DependencyInjection.Extensions;
              {{string.Join("\n", namespaces.Select(@namespace => $"using {@namespace};"))}}
              
              namespace Mediator.DependencyInjection;
              
              internal static class MediatorHandlerDependencyInjectionExtension
              {
                internal static MediatorBuilder AddHandlers(this MediatorBuilder builder)
                {
                    {{string.Join("\n\n\t\t", handlers.Select(handler => $"builder.Services.TryAddTransient<IRequestHandler<{handler.GenericType}>, {handler.FullyQualifiedClassName}>();"))}}
                    
                    return builder;
                }
              }
              
              """);
    }
}