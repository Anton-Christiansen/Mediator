using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Mediator.SourceGenerators;

[Generator]
public class NotificationIncrementalGenerator : IIncrementalGenerator
{
    private record Information(string Namespace, string FullyQualifiedClassName, string RequestName)
    {
        public string Namespace { get; } = Namespace;
        public string FullyQualifiedClassName { get; } = FullyQualifiedClassName;
        public string RequestName { get; } = RequestName;
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.CreateSyntaxProvider(
                static (node, _) => node is ClassDeclarationSyntax,
                static (ctx, _) => Transform(ctx))
            .Where(x => x.Found)
            .Select((x, _) => x.Info!);

        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
    }


    private static (Information? Info, bool Found) Transform(
        GeneratorSyntaxContext context)
    {
        var declaration = (ClassDeclarationSyntax)context.Node;

        var symbol = (INamedTypeSymbol)context.SemanticModel.GetDeclaredSymbol(declaration)!;


        var result = GetInformationFromSymbol(symbol, out var information);
        return (information, result);
    }


    private static bool GetInformationFromSymbol(INamedTypeSymbol symbol, out Information? information)
    {
        information = null;
        foreach (var @interface in symbol.AllInterfaces)
        {
            if (@interface.Name.Contains("INotificationHandler") is false) continue;
            string interfaceName = @interface.ToString();
            int start = interfaceName.IndexOf('<');
            int end = interfaceName.LastIndexOf('>');
            interfaceName = interfaceName.Substring(start + 1, end - start - 1);

            information = new Information(symbol.ContainingNamespace.ToString(), symbol.ToString(), interfaceName);
            return true;
        }

        return false;
    }

    public static IEnumerable<INamedTypeSymbol> GetAllTypes(INamespaceSymbol ns)
    {
        foreach (var type in ns.GetTypeMembers())
            yield return type;

        foreach (var nestedNs in ns.GetNamespaceMembers())
        {
            foreach (var t in GetAllTypes(nestedNs))
            {
                yield return t;
                
                foreach (var l in t.GetTypeMembers())
                {
                    yield return l;
                }
            }
        }
    }


    private static void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<Information> information)
    {
        // Looking through already compiled code, looking to find anything to generate
        foreach (var assembly in compilation.SourceModule.ReferencedAssemblySymbols)
        {
            foreach (var type in GetAllTypes(assembly.GlobalNamespace))
            {
                if (type.TypeKind != TypeKind.Class) continue;

                if (GetInformationFromSymbol(type, out var info) is false) continue;

                information = information.Add(info!);
            }
        }

        // If nothing found we return early
        if (information.Length == 0) return;


        var namespaces = information.Select(x => x.Namespace).Distinct().ToArray();

        
        context.AddSource($"MediatorNotificationDependencyInjection.g.cs",
            $$"""
              // <auto-generated/>

              using System;
              using Mediator.Interfaces;
              using Mediator.Helpers;
              using Microsoft.Extensions.DependencyInjection;
              using Microsoft.Extensions.DependencyInjection.Extensions;
              {{string.Join("\n", namespaces.Select(@namespace => $"using {@namespace};"))}}

              namespace Mediator.DependencyInjection;

              internal static class NotificationDependencyInjectionRegistrationExtensions
              {
                internal static MediatorBuilder AddNotifications(this MediatorBuilder builder)
                {
                    {{string.Join("\n\t\t", information.Select(info => $"builder.Services.AddTransient<INotificationHandler<{info.RequestName}>, {info.FullyQualifiedClassName}>();"))}}
                    
                    return builder;
                }
              }

              """);
    }
}